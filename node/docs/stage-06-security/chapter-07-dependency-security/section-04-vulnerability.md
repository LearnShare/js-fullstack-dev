# 6.7.4 漏洞扫描与修复

## 1. 概述

漏洞扫描与修复是依赖安全管理的核心流程，包括漏洞检测、风险评估、修复方案和实施修复。本章介绍完整的漏洞扫描和修复流程。

## 2. 漏洞扫描流程

### 2.1 扫描步骤

```ts
interface VulnerabilityScan {
  package: string;
  version: string;
  vulnerabilities: Vulnerability[];
  severity: 'critical' | 'high' | 'moderate' | 'low';
}

interface Vulnerability {
  id: string;
  title: string;
  severity: string;
  description: string;
  fixedIn?: string[];
  cwe?: string[];
}

async function scanDependencies(): Promise<VulnerabilityScan[]> {
  // 1. 读取 package.json
  const packageJson = JSON.parse(await readFile('package.json', 'utf8'));
  
  // 2. 扫描依赖
  const scans: VulnerabilityScan[] = [];
  
  for (const [name, version] of Object.entries(packageJson.dependencies)) {
    const vulnerabilities = await checkVulnerabilities(name, version);
    if (vulnerabilities.length > 0) {
      scans.push({
        package: name,
        version: version as string,
        vulnerabilities,
        severity: getMaxSeverity(vulnerabilities)
      });
    }
  }
  
  return scans;
}
```

### 2.2 风险评估

```ts
function assessRisk(vulnerability: Vulnerability, packageUsage: string[]): 'high' | 'medium' | 'low' {
  let risk: 'high' | 'medium' | 'low' = 'low';
  
  // 严重性评估
  if (vulnerability.severity === 'critical' || vulnerability.severity === 'high') {
    risk = 'high';
  } else if (vulnerability.severity === 'moderate') {
    risk = 'medium';
  }
  
  // 使用情况评估
  if (packageUsage.includes('production')) {
    risk = risk === 'low' ? 'medium' : 'high';
  }
  
  return risk;
}
```

## 3. 修复方案

### 3.1 修复策略

```ts
interface FixStrategy {
  package: string;
  currentVersion: string;
  targetVersion: string;
  strategy: 'patch' | 'minor' | 'major' | 'replace';
  risk: 'low' | 'medium' | 'high';
  breakingChanges: boolean;
}

async function generateFixStrategy(
  packageName: string,
  currentVersion: string,
  vulnerability: Vulnerability
): Promise<FixStrategy> {
  // 查找修复版本
  const fixedVersions = vulnerability.fixedIn || [];
  const latestVersion = await getLatestVersion(packageName);
  
  let strategy: 'patch' | 'minor' | 'major' | 'replace' = 'patch';
  let targetVersion = currentVersion;
  let breakingChanges = false;
  
  // 选择最小修复版本
  for (const fixedVersion of fixedVersions) {
    if (isNewerVersion(fixedVersion, currentVersion)) {
      targetVersion = fixedVersion;
      break;
    }
  }
  
  // 判断更新类型
  const versionDiff = compareVersions(currentVersion, targetVersion);
  if (versionDiff.major > 0) {
    strategy = 'major';
    breakingChanges = true;
  } else if (versionDiff.minor > 0) {
    strategy = 'minor';
  } else {
    strategy = 'patch';
  }
  
  return {
    package: packageName,
    currentVersion,
    targetVersion,
    strategy,
    risk: breakingChanges ? 'high' : 'low',
    breakingChanges
  };
}
```

### 3.2 自动修复

```ts
import { exec } from 'node:child_process';
import { promisify } from 'node:util';

const execAsync = promisify(exec);

async function applyFix(strategy: FixStrategy): Promise<boolean> {
  try {
    // 更新 package.json
    const packageJson = JSON.parse(await readFile('package.json', 'utf8'));
    packageJson.dependencies[strategy.package] = `^${strategy.targetVersion}`;
    await writeFile('package.json', JSON.stringify(packageJson, null, 2));
    
    // 安装更新
    await execAsync('npm install');
    
    // 运行测试
    await execAsync('npm test');
    
    return true;
  } catch (error) {
    console.error('Fix failed:', error);
    return false;
  }
}
```

## 4. 修复验证

### 4.1 测试验证

```ts
async function verifyFix(packageName: string, targetVersion: string): Promise<boolean> {
  // 1. 检查版本
  const installedVersion = await getInstalledVersion(packageName);
  if (installedVersion !== targetVersion) {
    return false;
  }
  
  // 2. 检查漏洞
  const vulnerabilities = await checkVulnerabilities(packageName, targetVersion);
  if (vulnerabilities.length > 0) {
    return false;
  }
  
  // 3. 运行测试
  try {
    await execAsync('npm test');
    return true;
  } catch (error) {
    return false;
  }
}
```

### 4.2 回滚机制

```ts
async function rollbackFix(packageName: string, previousVersion: string): Promise<void> {
  const packageJson = JSON.parse(await readFile('package.json', 'utf8'));
  packageJson.dependencies[packageName] = previousVersion;
  await writeFile('package.json', JSON.stringify(packageJson, null, 2));
  await execAsync('npm install');
}
```

## 5. 持续监控

### 5.1 监控脚本

```ts
import cron from 'node-cron';

// 每天检查漏洞
cron.schedule('0 0 * * *', async (): Promise<void> => {
  const scans = await scanDependencies();
  const criticalVulns = scans.filter((s: VulnerabilityScan) => s.severity === 'critical');
  
  if (criticalVulns.length > 0) {
    await sendAlert({
      subject: 'Critical vulnerabilities detected',
      body: JSON.stringify(criticalVulns, null, 2)
    });
  }
});
```

### 5.2 CI/CD 集成

```yaml
name: Security Scan

on: [push, pull_request]

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npm audit --audit-level=high
      - name: Snyk Scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
```

## 6. 最佳实践

### 6.1 扫描策略

- 定期扫描
- CI/CD 集成
- 实时监控
- 告警机制

### 6.2 修复策略

- 优先修复严重漏洞
- 测试修复方案
- 记录修复过程
- 验证修复效果

## 7. 注意事项

- **测试验证**：修复后充分测试
- **版本兼容**：注意版本兼容性
- **回滚准备**：准备回滚方案
- **持续监控**：持续监控依赖安全

## 8. 常见问题

### 8.1 如何处理无法修复的漏洞？

寻找替代方案、使用补丁、联系维护者。

### 8.2 如何平衡安全性和兼容性？

优先修复严重漏洞，测试兼容性，逐步更新。

### 8.3 如何建立修复流程？

制定修复策略、建立测试流程、记录修复历史。

## 9. 实践任务

1. **漏洞扫描**：实现漏洞扫描功能
2. **风险评估**：实现风险评估功能
3. **修复方案**：生成修复方案
4. **自动修复**：实现自动修复功能
5. **持续监控**：建立持续监控机制

---

**阶段六完成**：恭喜完成阶段六的学习！可以继续学习阶段七：测试与质量保证。
