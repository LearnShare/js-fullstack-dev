# 4.12.1 请求验证概述

## 1. 概述

请求验证是 API 开发中的重要环节，确保接收到的数据符合预期格式和业务规则。请求验证可以防止无效数据进入系统，提高应用的安全性和稳定性。

## 2. 核心概念

### 2.1 验证的目的

- **数据完整性**：确保数据完整和正确
- **安全性**：防止恶意数据注入
- **业务规则**：验证业务规则
- **类型安全**：确保数据类型正确

### 2.2 验证的层次

- **输入验证**：验证请求参数
- **业务验证**：验证业务规则
- **输出验证**：验证响应数据

## 3. 验证类型

### 3.1 类型验证

- **字符串**：验证字符串格式
- **数字**：验证数字范围和类型
- **布尔值**：验证布尔值
- **日期**：验证日期格式

### 3.2 格式验证

- **邮箱**：验证邮箱格式
- **URL**：验证 URL 格式
- **正则表达式**：使用正则表达式验证

### 3.3 业务验证

- **范围验证**：验证数值范围
- **长度验证**：验证字符串长度
- **必填验证**：验证必填字段
- **唯一性验证**：验证数据唯一性

## 4. 验证库对比

### 4.1 Zod

**特点**：
- TypeScript 优先
- 类型推断
- 链式 API
- 零依赖

### 4.2 Joi

**特点**：
- 功能丰富
- 链式 API
- 广泛使用
- JavaScript/TypeScript 支持

### 4.3 class-validator

**特点**：
- 基于装饰器
- 类验证
- NestJS 集成
- TypeScript 支持

## 5. 验证位置

### 5.1 客户端验证

- 提供即时反馈
- 减少服务器负载
- 提升用户体验

### 5.2 服务器端验证

- 安全性保障
- 数据完整性
- 业务规则验证

## 6. 最佳实践

### 6.1 验证策略

- 客户端和服务器端都验证
- 使用验证库
- 提供清晰的错误信息

### 6.2 错误处理

- 返回详细的验证错误
- 使用标准错误格式
- 记录验证失败

## 7. 注意事项

- **安全性**：验证所有输入数据
- **性能**：注意验证的性能影响
- **用户体验**：提供清晰的错误信息
- **可维护性**：保持验证逻辑清晰

## 8. 常见问题

### 8.1 为什么需要服务器端验证？

客户端验证可以被绕过，服务器端验证是安全性的保障。

### 8.2 如何选择验证库？

根据项目需求、技术栈和团队经验选择。

### 8.3 如何处理验证错误？

返回详细的错误信息，使用标准错误格式。

## 9. 相关资源

- [Zod 文档](https://zod.dev/)
- [Joi 文档](https://joi.dev/)
- [class-validator 文档](https://github.com/typestack/class-validator)

---

**下一节**：[4.12.2 Zod 数据校验](section-02-zod.md)
