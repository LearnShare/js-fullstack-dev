# 2.9.3 正则表达式基础

## 概述

正则表达式用于文本的匹配、查找、提取与替换。掌握模式语法（字符类、量词、分组、边界）、标志位、常?API，以及避免回溯灾难的写法，可帮助你编写高效可维护的文本处理逻辑?

## 创建正则表达?

### 字面?
```js
const re = /pattern/;
const re2 = /pattern/gi; // g: 全局, i: 忽略大小?
```

### 构造函?
```js
const re = new RegExp('pattern');
const re2 = new RegExp('pattern', 'gi');
```
当模式需动态拼接时使用构造函数，注意对特殊字符进行转义?

## 常用标志?
- `g` 全局匹配
- `i` 忽略大小?
- `m` 多行（`^`/`$` 匹配行首/行尾?
- `s` 允许 `.` 匹配换行（dotAll?
- `u` Unicode，启?Unicode 感知（推荐处理多语言/emoji?
- `y` 粘连匹配（从 lastIndex 开始必须紧邻匹配）

## 核心模式语法

### 字符?
```js
\d   // 数字 [0-9]
\w   // 单词字符 [A-Za-z0-9_]
\s   // 空白
[^...] // 取反
[a-z] [A-Z] [0-9]
```
> 注意：`\w` 不包含中文；多语言请用 `\p{Letter}`（需 u 标志）?

### 量词
```js
*    // 0 到多
+    // 1 到多
?    // 0 ?1
{n}  // 恰好 n
{n,} // 至少 n
{n,m}// n ?m
```

### 贪婪 vs 惰?
```js
const str = '<tag>text</tag>';
str.match(/<.*>/);   // ["<tag>text</tag>"] 贪婪
str.match(/<.*?>/);  // ["<tag>"] 惰?
```

### 分组与捕?
```js
const re = /(\d{4})-(\d{2})-(\d{2})/;
const [, y, m, d] = '2024-05-20'.match(re);
```

非捕获分组：`(?:...)`，用于分组但不捕获，提高性能/减少结果噪声?

### 反向引用
```js
// 匹配重复单词：word word
/\b(\w+)\s+\1\b/i.test('Hello hello'); // true
```

### 边界
```js
^  // ?字符串开头（m 标志影响?
$  // 结尾
\b // 单词边界
```

## 常用 API

### test() 方法

**语法格式**：`regexp.test(str)`

**参数说明**?

| 参数?  | 类型   | 说明                           | 是否必需 | 默认?|
|:---------|:-------|:-------------------------------|:---------|:-------|
| `str`    | string | 要测试的字符?                | ?      | -      |

**返回?*：布尔值，如果正则表达式匹配字符串返回 `true`，否则返?`false`

**示例**?

```js
/hello/i.test('Hello'); // true
/hello/i.test('World'); // false
```

### match() 方法

**语法格式**：`str.match(regexp)`

**参数说明**?

| 参数?    | 类型         | 说明                           | 是否必需 | 默认?|
|:-----------|:-------------|:-------------------------------|:---------|:-------|
| `regexp`   | RegExp\|string | 正则表达式对象或字符?        | ?      | -      |

**返回?*?
- 如果使用全局标志（`g`），返回匹配结果的数组，如果没有匹配返回 `null`
- 如果不使用全局标志，返回第一个匹配结果及其捕获组，如果没有匹配返?`null`

**示例**?

```js
'a1b2'.match(/\d/g);           // ["1","2"]
'a1b2'.match(/\d/);            // ["1", index: 1, input: "a1b2", groups: undefined]
'abc'.match(/\d/g);            // null
```

### matchAll() 方法

**语法格式**：`str.matchAll(regexp)`

**参数说明**?

| 参数?    | 类型         | 说明                           | 是否必需 | 默认?|
|:-----------|:-------------|:-------------------------------|:---------|:-------|
| `regexp`   | RegExp       | 正则表达式对象（必须使用全局标志 `g`?| ?      | -      |

**返回?*：返回一个迭代器，包含所有匹配结果及其详细信息（索引、捕获组等）

**示例**?

```js
const matches = [...'a1b2'.matchAll(/\d/g)];
// [
//   ["1", index: 1, input: "a1b2", groups: undefined],
//   ["2", index: 3, input: "a1b2", groups: undefined]
// ]
```

### search() 方法

**语法格式**：`str.search(regexp)`

**参数说明**?

| 参数?    | 类型         | 说明                           | 是否必需 | 默认?|
|:-----------|:-------------|:-------------------------------|:---------|:-------|
| `regexp`   | RegExp\|string | 正则表达式对象或字符?        | ?      | -      |

**返回?*：数字，返回第一个匹配的索引位置，如果没有匹配返?`-1`

**示例**?

```js
'abc123'.search(/\d+/); // 3
'abc'.search(/\d+/);    // -1
```

### replace() 方法

**语法格式**：`str.replace(regexp|substr, newSubstr|function)`

**参数说明**?

| 参数?         | 类型         | 说明                           | 是否必需 | 默认?|
|:----------------|:-------------|:-------------------------------|:---------|:-------|
| `regexp\|substr` | RegExp\|string | 正则表达式或要替换的子字符串   | ?      | -      |
| `newSubstr\|function` | string\|Function | 替换字符串或替换函数 | ?      | -      |

**返回?*：字符串，返回替换后的新字符串（原字符串不变?

**说明**?
- 如果第一个参数是字符串，只替换第一个匹?
- 如果第一个参数是正则表达式且使用全局标志（`g`），替换所有匹?
- 替换函数接收参数：`(match, p1, p2, ..., offset, string, groups)`

**示例**?

```js
'abc123'.replace(/\d+/g, '#');        // "abc#"
'a1b2'.replace(/\d/g, m => `[${m}]`); // "a[1]b[2]"
'hello world'.replace('world', 'JS'); // "hello JS"
```

### replaceAll() 方法

**语法格式**：`str.replaceAll(regexp|substr, newSubstr|function)`

**参数说明**?

| 参数?         | 类型         | 说明                           | 是否必需 | 默认?|
|:----------------|:-------------|:-------------------------------|:---------|:-------|
| `regexp\|substr` | RegExp\|string | 正则表达式（必须使用全局标志 `g`）或要替换的子字符串 | ?      | -      |
| `newSubstr\|function` | string\|Function | 替换字符串或替换函数 | ?      | -      |

**返回?*：字符串，返回替换后的新字符串（原字符串不变?

**说明**：与 `replace()` 类似，但会替换所有匹配（不需要全局标志?

**示例**?

```js
'hello world world'.replaceAll('world', 'JS'); // "hello JS JS"
'a1b2'.replaceAll(/\d/g, '#');                // "a#b#"
```

### split() 方法

**语法格式**：`str.split([separator[, limit]])`

**参数说明**?

| 参数?       | 类型         | 说明                           | 是否必需 | 默认?|
|:--------------|:-------------|:-------------------------------|:---------|:-------|
| `separator`   | RegExp\|string | 分隔符（正则表达式或字符串）   | ?      | -      |
| `limit`       | number       | 限制返回数组的最大长?        | ?      | -      |

**返回?*：数组，返回分割后的字符串数?

**示例**?

```js
'a  b   c'.split(/\s+/);        // ["a","b","c"]
'a,b,c'.split(',');             // ["a","b","c"]
'a,b,c'.split(',', 2);          // ["a","b"]
```

### exec() 方法

**语法格式**：`regexp.exec(str)`

**参数说明**?

| 参数?  | 类型   | 说明                           | 是否必需 | 默认?|
|:---------|:-------|:-------------------------------|:---------|:-------|
| `str`    | string | 要匹配的字符?                | ?      | -      |

**返回?*?
- 如果匹配成功，返回匹配结果数组（包含捕获组），并更新 `lastIndex` 属?
- 如果匹配失败，返?`null`

**说明**：与 `match()` 类似，但 `exec()` 是正则表达式对象的方法，可以用于循环匹配

**示例**?

```js
const re = /\d+/g;
re.exec('a1b2'); // ["1", index: 1, input: "a1b2", groups: undefined]
re.exec('a1b2'); // ["2", index: 3, input: "a1b2", groups: undefined]
re.exec('a1b2'); // null
```

## Unicode 与多语言匹配

- 使用 `u` 标志启用 Unicode 感知?
- 匹配任意字母：`\p{L}`（需 `u`）?
- 匹配 emoji/扩展字符时建议使?`u`，避?surrogate pair 被拆分?

示例?
```js
const re = /\p{L}+/gu;
console.log('你好Hello'.match(re)); // ["你好","Hello"]
```

## 常用实战片段

### 1) 邮箱（简化）
```js
const emailRe = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
```

### 2) URL（简化）
```js
const urlRe = /^https?:\/\/[^\s/$.?#].[^\s]*$/i;
```

### 3) 提取数字
```js
'价格：?23.50'.match(/\d+(\.\d+)?/); // ["123.50", ".50"]
```

### 4) 去除 HTML 标签（简化）
```js
const text = html.replace(/<[^>]+>/g, '');
```

### 5) 千分位分?
```js
const num = '1234567';
num.replace(/\B(?=(\d{3})+(?!\d))/g, ','); // "1,234,567"
```

## 性能与回?

- 避免灾难性回溯：减少嵌套量词，如 `/^(a+)+$/` 对长字符串会极慢?
- 用非捕获分组、明确边界、合理量词上限?
- 大文本重复匹配使?`y`（粘连）或手动推?`lastIndex`，减少回溯?

## 转义与动态构?

动态构造正则需对输入做转义?
```js
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

const keyword = 'a+b';
const re = new RegExp(escapeRegExp(keyword), 'g');
```

## 常见陷阱

- 忘记 `g` 导致 `replace` 只替换首个匹配? 
- 未使?`u` 处理 Unicode，导?emoji 匹配异常? 
- 使用贪婪量词导致匹配过长；需要时?`?` 改为惰性? 
- 复杂正则缺少注释/分段，后期难维护。可使用 `x` 风格（在 JS 中可拆分字符串加注释）? 

## 最佳实?

1) 对用户输入动态构造正则前先转义? 
2) 处理多语言/emoji 时加 `u` 标志，使?`\p{...}`? 
3) 优先非捕获分?`(?:...)`，仅在需要结果时使用捕获组? 
4) 编写复杂模式时分段注释，或拆成多个可读的子正则组合? 
5) 避免嵌套量词造成回溯灾难，必要时设置明确上限? 
6) 在性能敏感场景预编译正则，重复使用同一实例? 

## 练习

1. 写一个手机号匹配正则（带国家码可选），并?`test` 验证? 
2. ?`matchAll` 提取文本中的所有链接及其起始索引? 
3. 将用户输入的关键字转义后高亮显示（使?`replace` + 回调）? 
4. 处理包含 emoji 的文本，统计 emoji 数量（使?`\p{Emoji}`，需 `u`）? 
5. 优化一个存在回溯风险的正则，添加上限或改写非贪婪? 

## 总结

- 正则核心要素：字符类、量词、分组、边界、标志位? 
- 常用 API：test/search/match/matchAll/replace/replaceAll/split? 
- 多语言/emoji 处理需 `u` 标志；动态构造要转义? 
- 避免回溯灾难，保持模式可读、可维护? 

完成本章学习后，继续学习下一章：Set ?Map?
